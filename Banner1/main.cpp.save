#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#define INF 0x3f3f3f3f
#define MAX(a, b) ((a)>(b)?(a):(b))
#define MIN(a, b) ((a)<(b)?(a):(b))
#define BFontWidth 21
#define BFontHeight 24
#define SFontWidth 18
#define SFontHeight 23
#define SFontWholeHeight 30
/*
一开始运行时会跳出，需要安装imagemagick
安装ImageMagick-6.3.9-0-Q8-windows-dll.exe

初步将图片放到背景中去，图片位置还没有缩放，并且位置事先固定好
*/
using namespace std;
const int maxn=100;
const int height=343;
const int width=515;
char inputAddr[50] = "input/"; //输入的相对地址
//图片在背景中最适合位置时（经过缩放后），左上角位于背景中的xy坐标，索引从0开始，所以减1。先固定好试试
int picInBg_x=209-1,picInBg_y=82-1;
//文字一开始写入到背景中的位置
int textInBg_x=width*0.06,textInBg_y=82-1+SFontWholeHeight;
/*
int r = value & 255;
int g = (value >> 8) & 255;
int bl = (value >> 16) & 255;

data(32bit): 8bit，b,g,r
*/

class BITMAP {
public:
	int w, h;
	int *data;
	BITMAP(int w_, int h_) :w(w_), h(h_) { data = new int[w*h]; }
	~BITMAP() { delete[] data; }
	int *operator[](int y) { return &data[y*w]; }
};

class Contour{
public:
    int w,h;
    int *left,*right,*upper,*bottom;
    int minleft,maxright,minupper,maxbottom;
    Contour(int w_,int h_):w(w_), h(h_) {
        left=new int[h];//存储每行最左边的边缘像素点是第几个
        right=new int[h];//存储每行最右边的边缘像素点是第几个
        upper=new int[w];//存储每列最上边的边缘像素点是第几个
        bottom=new int[w];//存储每列最下边的边缘像素点是第几个
        minleft=minupper=INF;
        maxright=maxbottom=0;
    }
    ~Contour(){
        delete[] left;
        delete[] right;
        delete[] upper;
        delete[] bottom;
    }
    int getLeft(int x){
        return left[x];
    }
    int getRight(int x){
        return right[x];
    }
    int getUpper(int x){
        return upper[x];
    }
    int getBottom(int x){
        return bottom[x];
    }
};
void check_im() {
	if (system("identify > null.txt") != 0) {
		fprintf(stderr, "ImageMagick must be installed, and 'convert' and 'identify' must be in the path\n"); exit(1);
	}
}

BITMAP *load_bitmap(char *filename) {
	check_im();
	char rawname[256], txtname[256];

	//char relAddr[50] = "input/";
	//strcat(relAddr, filename);
	//strcpy(filename, relAddr);

	strcpy(rawname, filename);
	strcpy(txtname, filename);
	if (!strstr(rawname, ".")) { fprintf(stderr, "Error reading image '%s': no extension found\n", filename); exit(1); }
	sprintf(strstr(rawname, "."), ".raw");  //strstr(str1,str2):look for str2 in str1 and return the first location, or return null.
	sprintf(strstr(txtname, "."), ".txt");
	char buf[256];
	sprintf(buf, "convert %s rgba:%s", filename, rawname);
	if (system(buf) != 0) { fprintf(stderr, "Error reading image '%s': ImageMagick convert gave an error\n", filename); system("pause"); exit(1); }
	sprintf(buf, "identify -format \"%%w %%h\" %s > %s", filename, txtname);
	if (system(buf) != 0) { fprintf(stderr, "Error reading image '%s': ImageMagick identify gave an error\n", filename); system("pause"); exit(1); }
	FILE *f = fopen(txtname, "rt");
	if (!f) { fprintf(stderr, "Error reading image '%s': could not read output of ImageMagick identify\n", filename); system("pause"); exit(1); }
	int w = 0, h = 0;  //"a.txt" "b.txt" stores values of w,h of pixels
	if (fscanf(f, "%d %d", &w, &h) != 2) { fprintf(stderr, "Error reading image '%s': could not get size from ImageMagick identify\n", filename); system("pause"); exit(1); }
	fclose(f);
	f = fopen(rawname, "rb");
	BITMAP *ans = new BITMAP(w, h);
	unsigned char *p = (unsigned char *)ans->data;
	//Read data about the picture, but why *4???
	for (int i = 0; i < w*h * 4; i++) {
		int ch = fgetc(f);
		if (ch == EOF) { fprintf(stderr, "Error reading image '%s': raw file is smaller than expected size %dx%dx4\n", filename, w, h, 4); system("pause"); exit(1); }
		*p++ = ch;
	}
	fclose(f);
	return ans;
}

/**
store the image from a bitmap.
*/
void save_bitmap(BITMAP *bmp, char *filename,int flag) {
	check_im();
	char rawname[256];
	char tmpname[256];
	char relAddr[50];//输入输出的图片相对于代码的位置，这样防止输出输入和代码都在一个文件里，very very mess.
	strcpy(tmpname, filename);  //先将filename拷贝到tmpname中去，不能用filename进行修改，因为是指针，会对filename造成改动
	if (flag == 0)
		strcpy(relAddr, inputAddr); //因为前一次结果要作为后一次的输入sheet，所以也要保存在input文件里
	else
		strcpy(relAddr, "output/"); //输出的相对位置
	strcat(relAddr, tmpname);
	strcpy(tmpname, relAddr);

	strcpy(rawname, tmpname);
	if (!strstr(rawname, ".")) { fprintf(stderr, "Error writing image '%s': no extension found\n", tmpname); system("pause"); exit(1); }
	sprintf(strstr(rawname, "."), ".raw");
	char buf[256];

	FILE *f = fopen(rawname, "wb");
	if (!f) { fprintf(stderr, "Error writing image '%s': could not open raw temporary file\n", tmpname); system("pause"); exit(1); }
	unsigned char *p = (unsigned char *)bmp->data;
	for (int i = 0; i < bmp->w*bmp->h * 4; i++) {
		fputc(*p++, f);
	}
	fclose(f);
	sprintf(buf, "convert -size %dx%d -depth 8 rgba:%s %s", bmp->w, bmp->h, rawname, tmpname);
	if (system(buf) != 0) { fprintf(stderr, "Error writing image '%s': ImageMagick convert gave an error\n", tmpname); system("pause"); exit(1); }
}

/**
look for '.' in "xxxx.png"
*/
int find_pos(char*src){
	int len = strlen(src);
	for (int i = 0; i < len; i++){
		if (src[i] == '.')
			return i;
	}
	return -1;
}

/**
get the Contour  Pixel Position of the picture
*/
void getContourPixel(BITMAP *a,Contour *&c){
    int ah=a->h,aw=a->w;
    c=new Contour(aw,ah);

    for(int ay=0;ay<ah;ay++){
        for(int ax=0;ax<aw;ax++){
            int value = (*a)[ay][ax];
            int dr = (value & 255);  //red
            int dg = ((value >> 8) & 255) ;  //green
            int db = (value >> 16)&255;  //blue
            //int dd = value >> 24; //depth
            if(dr<=250||dg<=250||db<=250){
                //if it is not white
                c.left[ay]=ax+1;
                c.minleft=min(c.minleft,ax+1);
                break;
            }
        }

        for(int ax=aw-1;ax>=0;ax--){
            int value = (*a)[ay][ax];
            int dr = (value & 255);  //red
            int dg = ((value >> 8) & 255) ;  //green
            int db = (value >> 16)&255;  //blue
            //int dd = value >> 24; //depth
            if(dr<=250||dg<=250||db<=250){
                //if it is not white
                c.right[ay]=ax+1;
                c.maxright=max(c.maxright,ax+1);
                break;
            }
        }
    }
    for(int ax=0;ax<aw;ax++){
        for(int ay=0;ay<ah;ay++){
            int value = (*a)[ay][ax];
            int dr = (value & 255);  //red
            int dg = ((value >> 8) & 255) ;  //green
            int db = (value >> 16)&255;  //blue
            //int dd = value >> 24; //depth
            if(dr<=250||dg<=250||db<=250){
                //if it is not white
                c.upper[ax]=ay+1;
                c.minupper=min(c.minupper,ay+1);
                break;
            }
        }

        for(int ay=ah-1;ay>=0;ay--){
            int value = (*a)[ay][ax];
            int dr = (value & 255);  //red
            int dg = ((value >> 8) & 255) ;  //green
            int db = (value >> 16)&255;  //blue
            //int dd = value >> 24; //depth
            if(dr<=250||dg<=250||db<=250){
                //if it is not white
                c.bottom[ax]=ay+1;
                c.maxbottom=max(c.maxbottom,ay+1);
                break;
            }
        }
    }
}

void putPicture(BITMAP *a, BITMAP *b, BITMAP *&res){
    int ah=a->h,aw=a->w;
    int bh=b->h,bw=b->w;

    res = new BITMAP(a->w, a->h);

    for(int ay=0;ay<ah;ay++){
        for(int ax=0;ax<aw;ax++){
            (*res)[ay][ax] = (*a)[ay][ax];
        }
    }

    for(int by=0;by<bh;by++){
        for(int bx=0;bx<bw;bx++){
            (*res)[picInBg_y+by][picInBg_x+bx]=(*b)[by][bx];
        }
    }
}

/**
写入说明文字到图片中去
*/
void writeExplain(char*explainFile,BITMAP*res,Contour *c,IplImage *&target,int lx,int ly){
    int len;
    char str[maxn];
    int nowlx=lx,nowly=ly;
    int wscale=1.0,hscale=1.0; //字体宽度、高度大小度量
    //wordlen:估算的单词所占像素宽度，wgap：单词之间水平间隔，设为一个字母宽度。hgap；说明文字行间距设置为字体高度的1/2吧
    int wordlen,wgap=SFontWidth,hgap=hscale*SFontHeight/2;
    //bool isLine=false;
    CvFont font;
    cvInitFont(&font,CV_FONT_HERSHEY_COMPLEX,wscale,hscale,0,2,8);

    FILE *f1;
    f1=fopen(explainFile,"r");

    while(fscanf(f1,"%s",str)!=EOF){
        len=strlen(str);
        wordlen=0;
        for(int i=0;i<len;i++){
            char ch=str[i];
            if(ch-'A'>=0 && ch-'A'<26){
                wordlen+=BFontWidth;
            }
            else{
                //小写字母以及标点符号，均按照小写字母宽度来处理
                wordlen+=SFontWidth;
            }
        }
        int dis=INF;
        /*
        判断单词右边距离图片边缘最小距离是否大于30像素
        */
        for(int k=SFontWholeHeight;k>=0;k--){
            int row=nowly+(SFontWholeHeight-SFontHeight)-k-picInBg_y;
            if(row>=0 && row<c.h)
                dis=min(c.left[row],dis);
        }
        if(nowlx+wordlen+30>picInBg_x+dis){
            //isLine=true;
            nowlx=lx;
            nowly=nowly+hgap;
        }

        cvPutText(target,str,cvPoint(nowlx,nowly),&font,cvScalar(0,0,0));

        nowlx+=wordlen+wgap;
    }
    fclose(f1);
}
/**
写入标题到图片中去
target:要写入文字内容的图片
l and r: 写的起始位置

注意；cvPutText中的cvPoint，是文字内容的最左下角。

picInBg_x,picInBg_y
*/
int writeTitle(char*titleFile,BITMAP*res,Contour *c,IplImage *&target,int lx,int ly){
    int ypos;
    int len;
    char str[maxn];
    int nowlx=lx,nowly=ly;
    int wscale=1.0,hscale=1.0; //字体宽度、高度大小度量
    //wordlen:估算的单词所占像素宽度，wgap：单词之间水平间隔，设为一个字母宽度。hgap；行间距设置为字体高度的1/3吧
    int wordlen,wgap=BFontWidth,hgap=hscale*BFontHeight/3;
    //bool isLine=false;
    CvFont font;
    cvInitFont(&font,CV_FONT_HERSHEY_COMPLEX,wscale,hscale,0,2,8);

    FILE *f1,*f2;
    f1=fopen(titleFile,"r");

    while(fscanf(f1,"%s",str)!=EOF){
        len=strlen(str);
        wordlen=BFontWidth*len;
        int dis=INF;
        /*
        判断单词右边距离图片边缘最小距离是否大于30像素
        */
        for(int k=BFontHeight;k>=0;k--){
            int row=nowly-k-picInBg_y;
            if(row>=0 && row<c.h)
                dis=min(c.left[row],dis);
        }
        if(nowlx+wordlen+30>picInBg_x+dis){
            //isLine=true;
            nowlx=lx;
            nowly=nowly+hgap;
        }

        cvPutText(target,str,cvPoint(nowlx,nowly),&font,cvScalar(0,0,0));

        nowlx+=wordlen+wgap;
    }
    fclose(f1);

    ypos=nowly;
    return ypos; //最后要返回标题的最下面的像素点纵坐标，这样好确定接下来写入的说明文字从哪开始
}

/**
file:已经插入图片后的背景图
titleFile：title的txt
explainFile:说明文字的txt
res：已经插入图片后的背景图的Bitmap
c：图片的边缘像素信息
*/
void writeText(char*file,char*titleFile,char*explainFile,BITMAP*res,Contour *c){
    char tmpstr[maxn];
    strcpy(tmpstr, inputAddr);
    strcat(tmpstr, file);

    IplImage * target;
	target = cvLoadImage(tmpstr, -1);

    int ly=writeTitle(titleFile,res,c,target,textInBg_x,textInBg_y);
    writeExplain(explainFile,res,c,target,textInBg_x,ly);

    cvSaveImage("resultWithText.jpg", target);
}
int main()
{

    char tmpstr[maxn];
    char bg[maxn]="background.jpg";
    char picture[maxn]="picture.jpg";
    char dest[maxn]="res1.jpg";
    strcpy(tmpstr, inputAddr);  //inputAddr存储的是相对地址，为全局变量，定义在代码最前面了。
    strcat(tmpstr, bg);
    BITMAP *a = load_bitmap(tmpstr);  //背景图

    strcpy(tmpstr, inputAddr);
    strcat(tmpstr, picture);
    BITMAP *b = load_bitmap(tmpstr);  //图片

    BITMAP *res=NULL;
    putPicture(a,b,res);
    save_bitmap(res,dest,0); //还是保存到input目录下

    Contour *c=NULL;
    getContourPixel(b,contorpixel);




    return 0;
}
